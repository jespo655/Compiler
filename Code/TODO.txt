



using.h
    decide exact syntax and usage, before implementing the class



Add a type class that just holds a list of types
    Function_call->get_type() should return one of those


Change get_type() to return a non-const type
    Pointer types has to change constantly when ownership changes
    (Or find another way to determine pointer ownership)



add functions that gets the type from a vector<Evaluated_value> and vector<Evaluated_variable>
    the only special case is function_call, which can return a list of type






check_types(std::vector<Evaluated_variable>, std::vector<Evaluated_value>)
    for use in assignment and declaration

virtual bool Abstx_node::try_resolve() = 0;


auto type = x->get_type();
if (x->fully_resolved) ASSERT(type != nullptr);
else if (type == nullptr) {
    if (!x->try_resolve()); {
        return; // maybe log something?
    }
    type = x->get_type();
    ASSERT(type != nullptr);
}


struct Type_defined_type : Type {
    std::shared_ptr<Type> identity;
    std::string name;
}


ATT TÄNKA PÅ:

Kanske: get_type() måste (KANSKE) returnera en const type, eller vara const själv.
(Måste man kalla get_type() på en typ? Man ska ju ändå alltid få Type_type i så fall)
(Att returnera en const type men inte själv vara const borde vara ok)











workspace

// global_scope har en workspace som parent (subklass till scope), och workspace har själv en pekare till global scope

Alla workspaces delar samma AST, men har olika entry points.
Alla #run skapar ett nytt workspace med den funktionen som entry point

Compiled_workspace är global / singleton; data i den kan ändras av compile-time fner


// någonstans globalt:
map<string, scope> global_scopes; // 1 global_scope per fil som kompileras




Compile_time exec tests:

Bygg funktioner manuellt, testa compile time execution av dem
 - någon bastyp-fn länkar till cpp-fner mha string fn-name. Switcha beroende på str.

