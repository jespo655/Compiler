




// foo :: fn(i:uint)->r:int {
    // #C #string here printf("hello world!\n"); here;
    // i = 2;
    // i = 3;
    // i = i;
    // i2 : int;
    // i2 = foo(i);
// };

// foo2, a := foo(2), 2;


// foo2 :: fn()->r:int {
//     a : int;
//     a = foo(0);
// };




// foo :: fn() -> r:int
// {
//     f :: -2;
//     f = foo();
//     bar();
// };
// f := foo(); // only here to force the scope of foo to be fully resolved


bar :: fn()
{
    baz();
};

baz :: fn() {
    #C #string here printf("hello world #!\n"); here;
};

#run bar();


/*
{
    // {}
    // while 651 { }
    // if 651 { }
    // elsif true {}
    // else {}
}
*/



// #set_entry_point bar();

// bar();

// hw :: fn($i:int, j:int)->c:int
// {
//     #C #string here printf("hello world #%d!\n", i); here;
//     c = i;
// };

// a := hw(-1, -2);

// } // extra } makes the compiler get stuck

// using "aksjdh.cb";

// main :: fn()
// {
//     // a.hw(-4);
//     // hw(-1,-2);
//     // {}
//     if true { {} {} {} }
//     elsif true {}
//     else {}
// };


// i : int = i2; // TODO: this should fail with cyclic dependency
// i2 : int = i;

// i :: b;

// s :: struct {
//     i := 2;
// };

// s2 :: s;
// a : s2;
// b :: s2;


// a, b, c := -1.4, true, "here";
// d, e, f := a, b, c;


// d := a;

/*
main :: fn() {
    // #C "printf(\"asd\")";
    #C #string C_CODE print("Hello, World!"); C_CODE
};
*/

