TODO:



// arrays (@arrays)

rhs continuation: [id/constant] (array lookup)

typer: kan ha array specifier:
    int [2] a; // a är en 2 lång array av ints (allockeras på stacken)
    int [..] a; // a är en dynamisk array av ints (allockeras på heapen, på stacken sparas endast en pekare)
    int [2,3] a; // a är en 2-dimensionell array av ints (sparas som en vanlig 1-dim)
    int [2,..] a; // (sparas på stacken som en array av pekare till int[..])
    int [..,2] a; // (sparas på heapen som en dynamisk array av int[2])

    [3] a; // error - no type (var försiktig med att inte blanda ihop detta med capture group)


// type checker:

compilation_unit
har en lista av saker som är beroende av den
har en counter på antalet saker den är beroende av

varje gång man lyckas få ner dependancy count till 0 -> resolva!
    sen -> gå igenom listan av dependants och minska deras dep.count med 1.

alla saker man behöver veta ska sparas i scope: typedefs, identifier namn med type, etc.



// Generic:

Tänk på "const" structs och hur tilldelning till dem sker
s : S();
s = s2; // error, s defined at ...
s.i = 2; // ok?

kanske lägga till "const" keyword -> inga struct members får ändras (utifrån?)





// Lexer:

UTF-8 encoding på alla identifiers - tillåt flera tecken (is_valid_char_in_identifier_name)
is_keyword(); kanske inte behövs?
UTF8-klass att använda istället för string
Here-strings
Se till att man kan läsa in symboler som "ser ut som" identifiers, utan att tappa data
    Ex: "and", "or"


// Parser:

Skriv tester!

Gå igenom allt och kolla end of file exceptions
    Se till att de hanteras på liknande sätt överallt

Enum med type, så att man senare med en enkel switch kan hitta rätt subklass

Överallt där man tittar på token -> se till att Token_type inte är STRING!
    annars kan man inte skilja på symbol ")" och string ")"

Gå igenom allt och kolla log_error-calls
    Allt ska returnera ptr.
    Om man anropar en funktion och får tillbaka nullptr -> returnera nullptr. Använd add_note om relevant.
    Om man gör något själv och hittar ett fel: anropa log_error och returnera nullptr.
Allt som returneras som inte är nullptr ska vara well-formed! Kolla ALLA tokens.
    När man får tillbaka nullptr - förvänta dig att log_error har anropats. Använd inte en funktion för att "testa"


Använd read_paren endast som en koll att allt stämmer. Oftast onödigt.

is_infix_operator()
infix operator - priorities

prefix operator - först i varje rhs-part

Workspace: innehåller global scope

read_rhs_part: array lookup "id[rhs]"

read_range: läs varje del av range definition, nuvarande lösning är väldigt temporär

Var ska man lägga till identifiers till scope?
    Ska inte lägga till om man är i function call context; endast om man är i static scope context

Read identifiers i capture group
Read statements i function_scope

Read keywords in the beginning of rhs: at least "fn" and "struct"



struct Type_identifier : Abs_syntax
{
    bool const; // not part of the type
}

struct Named_identifier
{
    Token const * name_token;
    unique_ptr<Type_identifier> type_id;
    // cast?
}


Istället för att skicka med en lista av tokens överallt: skicka med const Token*first och const Token*last.
    Beginning of list-check är inte nödvändig.
    Börja med const Token* it = first

Gå över till jai-stype := assignment syntax.







read_casts
read_identifier (med/utan type, namn, cast)
read_lhs_part (med parent scope - kolla om den redan är definierad)
read_lhs
read_rhs
read_assignment (identifiera lhs och rhs, räkna ej)
read_function_call
read_function_definition
read_statement
read_scope (skapar en lista av alla parallella statements, alla definierade identifiers)


// kanske:
skicka hela tiden med last, där last är garanterat efter det förväntade slutet på statement











Hitta ett bra sätt att hantera unknown type av identifiers
typade funktionsvariabler i LHS? (Komplicerar en hel del saker)
Alla listor sorterade, alla sökningar binära
när vi hittar en type som inte finns i global scope:
    add the type info to the local scope. For this we need to know the size of the type first.

read_comma_separated_identifier_list-version som returnerar LHS

kolla att inheritence funkar som det ska, med alla destruktorer och konstruktorer










// Kanske:

kombinering av funktioner och andra RHS-listor till en enda RHS?
    (onödigt för vanlig assignment, men användbart för return-statements)
    (kanske special för return-statements?)



// fixas när jag lägger till importering av scopes:
get_identifier(scope,id): problem med parent scope om man importerar ett scope som har samma parent
    (man får ambiguous_error från samma variabel 2 gånger pga 2 olika sökvägar)

ex:
    a {
        int i;
        b {
            c {

            }
            using c;
        }
    }
ambiguous definition of i: c->b->a->i och b->a->i


// capture groups
skilj på capture by reference / value
istället för att pulla in parent scope: lägg endast till specificerade identifiers







// inte så viktigt:

wrappa compiler i ett namespace
file ending

